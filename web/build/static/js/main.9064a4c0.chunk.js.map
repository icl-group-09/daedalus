{"version":3,"sources":["components/gpu/RenderType.tsx","components/gpu/ThreeHandler.ts","components/gpu/GPUView.tsx","components/menu/PcdMenu.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["RenderType","ThreeHandler","width","height","canvas","renderer","THREE","alpha","antialias","scene","camera","currentFile","points","originalPointsColors","this","initCamera","initRenderer","initControls","setPath","load","cubeTexture","skybox","material","envMap","mesh","add","background","render","filename","baseFilename","map","side","createPathStrings","image","texture","materialArray","createMaterialArray","console","log","skyboxGeo","position","set","setPixelRatio","window","devicePixelRatio","setSize","controls","OrbitControls","domElement","addEventListener","renderScene","minDistance","maxDistance","aspect","pcdFilename","renderType","pcdPointSize","undefined","PCDLoader","remove","geometry","getAttribute","rotateX","Math","PI","setPointsProperties","useVertexColors","HM","renderHeatMap","setAttribute","size","vertexColors","center","numPoints","attributes","count","minY","maxY","i","y","array","range","colors","j","heightProp","color","push","r","g","b","instance","GPUView","graphicsHandler","pcdRenderType","css","gpuViewRef","React","createRef","useEffect","current","children","length","appendChild","renderPCD","resizeRenderer","className","style","id","ref","PcdMenu","pcd","setPcd","textAlign","display","flexDirection","alignItems","justifyContent","Box","sx","minWidth","FormControl","fullWidth","Select","labelId","value","label","onChange","event","target","MenuItem","EnableGPUContext","createContext","document","createElement","DUMMY_GRAPHICS_HANDLER","App","useState","pointSize","setPointSize","innerWidth","w","setW","innerHeight","h","setH","onWindowResize","funkyFunc","x","pcdName","PCD","pointCloudType","setPointCloudType","useContext","getInstance","left","top","onClick","axis","xmax","xstep","xmin","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.9064a4c0.chunk.js","sourcesContent":["export enum RenderType {\n  PCD,\n  HM,\n}\n","import * as THREE from \"three\";\nimport { PCDLoader } from \"three/examples/jsm/loaders/PCDLoader\";\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\nimport { RenderType } from \"./RenderType\";\n\nexport interface IGraphicsHandler {\n  renderPCD(pcdFilename: String, mode: RenderType, pcdPointSize: number): void;\n  resizeRenderer(width: number, height: number): void;\n}\n\nexport class ThreeHandler implements IGraphicsHandler {\n  private readonly renderer: THREE.WebGLRenderer = new THREE.WebGLRenderer({\n    alpha: true,\n    antialias: true\n  });\n\n  private readonly scene: THREE.Scene = new THREE.Scene();\n  private camera: THREE.PerspectiveCamera;\n  private currentFile?: String;\n  private points?: THREE.Points<\n    THREE.BufferGeometry,\n    THREE.Material | THREE.Material[]\n  >;\n  private originalPointsColors?:\n    | THREE.BufferAttribute\n    | THREE.InterleavedBufferAttribute;\n\n  private static instance: ThreeHandler;\n\n  private constructor(width: number, height: number, canvas: HTMLCanvasElement) {\n    this.camera = new THREE.PerspectiveCamera(30, width / height, 0.01, 40);\n    this.renderer = new THREE.WebGLRenderer({ canvas: canvas });\n    this.initCamera();\n    this.initRenderer(width, height);\n    this.initControls();\n    \n    new THREE.CubeTextureLoader()\n    .setPath('/')\n    .load(\n        // urls of images used in the cube texture\n        [\n            'purplenebula_ft.png',\n            'purplenebula_bk.png',\n            'purplenebula_lf.png',\n            'purplenebula_rt.png',\n            'purplenebula_up.png',\n            'purplenebula_dn.png'\n        ],\n        // what to do when loading is over\n         (cubeTexture) => {\n            // Geometry\n            const skybox = new THREE.BoxGeometry(10000, 10000, 10000);\n            // Material\n            var material = new THREE.MeshBasicMaterial({\n                // CUBE TEXTURE can be used with\n                // the environment map property of\n                // a material.\n                envMap: cubeTexture\n            });\n            // Mesh\n            var mesh = new THREE.Mesh(skybox, material);\n            this.scene.add(mesh);\n            // CUBE TEXTURE is also an option for a background\n            this.scene.background = cubeTexture;\n            this.renderer.render(this.scene, this.camera);\n        }\n    );\n  }\n\n  private createPathStrings(filename: String) {\n    const basePath = \"/\";\n    const baseFilename = basePath + filename;\n    const fileType = \".png\";\n    const sides = [\"ft\", \"bk\", \"up\", \"dn\", \"rt\", \"lf\"];\n    const pathStrings = sides.map(side => {\n      return baseFilename + \"_\" + side + fileType;\n    });\n    return pathStrings;\n  }\n\n  private createMaterialArray(filename: String) {\n    const skyboxImagepaths = this.createPathStrings(filename);\n    const materialArray = skyboxImagepaths.map(image => {\n      let texture = new THREE.TextureLoader().load(image);\n      return new THREE.MeshBasicMaterial({ map: texture, side: THREE.BackSide }); // <---\n    });\n    return materialArray;\n  }\n\n  private initSkyBox() {\n    const materialArray = this.createMaterialArray(\"purplenebula\");\n    console.log(materialArray);\n    const skyboxGeo = new THREE.BoxGeometry(10000, 10000, 10000);\n    const skybox = new THREE.Mesh(skyboxGeo, materialArray);\n    this.scene.add(skybox);\n  }\n\n  public static getInstance(width: number, height: number, canvas: HTMLCanvasElement): ThreeHandler {\n    if (!ThreeHandler.instance) {\n      ThreeHandler.instance = new ThreeHandler(width, height, canvas);\n    }\n    return ThreeHandler.instance;\n  }\n\n  private initCamera() {\n    /// this.camera.position.set(0, 0, 1);\n    this.camera.position.set(1200, -250, 2000);\n    this.scene.add(this.camera);\n  }\n\n  private initRenderer(width: number, height: number) {\n    this.renderer.setPixelRatio(window.devicePixelRatio);\n    this.renderer.setSize(width, height);\n  }\n\n  private initControls() {\n    const controls = new OrbitControls(this.camera, this.renderer.domElement);\n    controls.addEventListener(\"change\", () => {\n      this.renderScene();\n    });\n    controls.minDistance = 0.5;\n    controls.maxDistance = 10;\n  }\n\n  resizeRenderer(width: number, height: number) {\n    this.camera.aspect = width / height;\n    this.renderer.setSize(width, height);\n  }\n\n  renderPCD(\n    pcdFilename: string,\n    renderType: RenderType,\n    pcdPointSize: number\n  ): void {\n    if (this.points === undefined || pcdFilename !== this.currentFile) {\n      this.currentFile = pcdFilename;\n      const loader = new PCDLoader();\n      loader.load(`/getPcd/${pcdFilename}.pcd`, points => {\n      // loader.load(\"/\" + pcdFilename + \".pcd\", points => {\n        if (this.points !== undefined) {\n          this.scene.remove(this.points);\n        }\n        this.points = points;\n        this.originalPointsColors = points.geometry.getAttribute(\"color\");\n        points.geometry.rotateX(Math.PI);\n        this.setPointsProperties(points, pcdPointSize, renderType);\n        this.scene.add(points);\n        this.renderScene();\n      });\n    } else {\n      this.setPointsProperties(this.points, pcdPointSize, renderType);\n      this.renderScene();\n    }\n  }\n\n  private setPointsProperties(\n    points: THREE.Points<\n      THREE.BufferGeometry,\n      THREE.Material | THREE.Material[]\n    >,\n    pcdPointSize: number,\n    renderType: RenderType\n  ) {\n    let useVertexColors = this.originalPointsColors !== undefined;\n\n    switch (renderType) {\n      case RenderType.HM: {\n        this.renderHeatMap(points);\n        useVertexColors = true;\n        break;\n      }\n      default: {\n        if (useVertexColors) {\n          points.geometry.setAttribute(\"color\", this.originalPointsColors!);\n        }\n        break;\n      }\n    }\n\n    points.material = new THREE.PointsMaterial({\n      size: pcdPointSize,\n      vertexColors: useVertexColors,\n    });\n    points.geometry.center();\n  }\n\n  private renderHeatMap(\n    points: THREE.Points<\n      THREE.BufferGeometry,\n      THREE.Material | THREE.Material[]\n    >\n  ) {\n    const numPoints = points.geometry.attributes.position.count;\n    var minY = 1000000;\n    var maxY = -1000000;\n    for (var i = 0; i < numPoints; i++) {\n      const y = points.geometry.attributes.position.array[i * 3 + 1];\n\n      if (y < minY) {\n        minY = y;\n      }\n\n      if (y > maxY) {\n        maxY = y;\n      }\n    }\n\n    const range = maxY - minY;\n\n    const colors = [];\n    for (var j = 0; j < numPoints; j++) {\n      const y = points.geometry.attributes.position.array[j * 3 + 1];\n      const heightProp = (y - minY) / range;\n      const color = new THREE.Color(heightProp, 0, 1 -heightProp);\n      colors.push(color.r, color.g, color.b);\n    }\n    points.geometry.setAttribute(\n      \"color\",\n      new THREE.Float32BufferAttribute(colors, 3)\n    );\n  }\n\n  private renderScene() {\n    this.renderer.render(this.scene, this.camera);\n  }\n}\n","import React from \"react\";\nimport { IGraphicsHandler } from \"./ThreeHandler\";\nimport { useEffect } from \"react\";\nimport {RenderType} from \"./RenderType\";\n\ntype GPUViewProps = {\n  width: number;\n  height: number;\n  graphicsHandler: IGraphicsHandler;\n  pcdFilename: string;\n  pcdRenderType: RenderType;\n  pcdPointSize: number;\n  canvas: HTMLCanvasElement;\n};\n\nconst GPUView = ({\n  width,\n  height,\n  graphicsHandler,\n  pcdFilename,\n  pcdRenderType,\n  pcdPointSize,\n  canvas,\n}: GPUViewProps) => {\n  const css = { width: `${width}px`, height: `${height}px` };\n\n  const gpuViewRef = React.createRef<HTMLDivElement>();\n\n  useEffect(() => {\n    // Run the first time this component renders\n     if (gpuViewRef.current!.children.length === 0) {\n       gpuViewRef.current!.appendChild(canvas);\n     }\n    graphicsHandler.renderPCD(pcdFilename, pcdRenderType, pcdPointSize);\n    graphicsHandler.resizeRenderer(width, height);\n\n  });\n\n  return (\n    <div className=\"gpu-view\" style={css}>\n      <div id=\"gpu-view-frame\" ref={gpuViewRef}></div>\n    </div>\n  );\n};\n\nexport default GPUView;\n","import React from \"react\";\nimport { Dispatch, SetStateAction } from \"react\";\nimport Box from \"@mui/material/Box\";\nimport MenuItem from \"@mui/material/MenuItem\";\nimport FormControl from \"@mui/material/FormControl\";\nimport Select, { SelectChangeEvent } from \"@mui/material/Select\";\n\ntype PcdMenuProps = {\n  pcd: string;\n  setPcd: Dispatch<SetStateAction<string>>;\n};\n\nconst PcdMenu = ({ pcd, setPcd }: PcdMenuProps) => {\n  const handleChange = (event: SelectChangeEvent) => {\n    setPcd(event.target.value as string);\n  };\n\n  var pcdList = [\"online\", \"Rf10\", \"frame_00023\"];\n\n  const menuStyle = {\n    textAlign: \"center\",\n    display: \"flex\",\n    flexDirection: \"column\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  } as const;\n\n  const menuColor = {\n    background: \"white\"\n  } as const;\n\n  return (\n    <div style={menuStyle}>\n      <div style={menuColor}>\n    <Box sx={{ minWidth: 120 }}>\n      <FormControl fullWidth>\n        {/* <InputLabel id=\"demo-simple-select-label\">PCD</InputLabel> */}\n        <Select\n          labelId=\"demo-simple-select-label\"\n          id=\"demo-simple-select\"\n          value={pcd}\n          label=\"Age\"\n          onChange={handleChange}\n        >\n          {pcdList.map((pcd, i) => {\n            return (\n              <MenuItem key={i} value={pcd}>\n                {pcd}\n              </MenuItem>\n            );\n          })}\n        </Select>\n      </FormControl>\n    </Box>\n    </div>\n    </div>\n  );\n};\nexport default PcdMenu;\n","import React from \"react\";\nimport \"./App.css\";\nimport { IGraphicsHandler, ThreeHandler } from \"./components/gpu/ThreeHandler\";\nimport { useState, createContext, useContext } from \"react\";\nimport GPUView from \"./components/gpu/GPUView\";\nimport PcdMenu from \"./components/menu/PcdMenu\";\nimport Slider from \"react-input-slider\";\n\nimport { RenderType } from \"./components/gpu/RenderType\";\n\nexport const EnableGPUContext = createContext(true);\n\nconst canvas: HTMLCanvasElement = document.createElement(\"canvas\");\n\nconst DUMMY_GRAPHICS_HANDLER: IGraphicsHandler = {\n  renderPCD: (pcdFilename: String) => {},\n  resizeRenderer: (width: number, height: number) => {},\n};\n\nfunction onWindowResize(setW: React.Dispatch<React.SetStateAction<number>>, \n  setH: React.Dispatch<React.SetStateAction<number>>) {\n  setW(window.innerWidth);\n  setH(window.innerHeight);\n}\n\nfunction App() {\n  // These are here just for the demo. Will be removed\n  const [pcd, setPcd] = useState(\"online\");\n  const [pointSize, setPointSize] = useState(0.003);\n  const [w, setW] = useState(window.innerWidth);\n  const [h, setH] = useState(window.innerHeight);\n  window.addEventListener(\"resize\", () => onWindowResize(setW, setH), false);\n\n  (window as any).funkyFunc = (x: number, y: number) => {\n    setW(x);\n    setH(y);\n  };\n\n  (window as any).setPcd = (pcdName: string) => {\n    setPcd(pcdName);\n  };\n\n  const [pointCloudType, setPointCloudType] = useState(RenderType.PCD);\n\n  const ClickPCD = () => {\n    setPointCloudType(RenderType.PCD);\n  };\n\n  const ClickHM = () => {\n    setPointCloudType(RenderType.HM);\n  };\n\n  const graphicsHandler = !useContext(EnableGPUContext)\n    ? DUMMY_GRAPHICS_HANDLER\n    : ThreeHandler.getInstance(w, h, canvas);\n\n  const cssCenter = {\n    textAlign: \"center\",\n    display: \"flex\",\n    flexDirection: \"column\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  } as const;\n\n  const cssControls = {\n    position: \"absolute\",\n    width: \"100%\",\n    left: \"0px\",\n    top: \"0px\",\n    color: \"white\"\n  } as const;\n\n\n  return (\n    <div className=\"App\" style={cssCenter}>\n      <div className = \"controls\" style={cssControls}>\n        <h1>Welcome to Daedalus!</h1>\n        <div>\n          <button onClick={ClickPCD}>Show Point Cloud</button>\n          <button onClick={ClickHM}>Show Heat Map</button>\n          <button>Show 2D Map</button>\n        </div>\n          <PcdMenu pcd={pcd} setPcd={setPcd}/>\n            <Slider\n              axis=\"x\"\n              xmax={0.1}\n              xstep={0.0005}\n              xmin={0.001}\n              x={pointSize}\n              onChange={({ x }) => setPointSize(x)}\n              />\n      </div>\n\n      <GPUView\n        width={w}\n        height={h}\n        graphicsHandler={graphicsHandler}\n        pcdFilename={pcd}\n        pcdRenderType={pointCloudType}\n        pcdPointSize={pointSize}\n        canvas={canvas}\n      />\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from \"web-vitals\";\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import(\"web-vitals\").then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}